{
  "hash": "df39b41513aeca02c4884900059583a9",
  "result": {
    "markdown": "---\ntitle: \"Application of Spatial and Spatio-temporal Analysis Methods to Discover the Distribution of Dengue Fever in Tainan City, Taiwan\"\nsubtitle: \"Take-home_Ex02\"\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\n    toc: true # Table of Contents\nexecute:\n  eval: true\n  echo: true\n  freeze: true\n  warning: False  # This turns off warning messages being displayed\ndate: 19 February, 2024\ndate-modified: \"last-modified\"\n---\n\n\n# 1.0 Introduction\n\n## 1.1 Overview\n\n[Dengue Hemorrhagic Fever](https://www.cdc.gov/dengue/resources/denguedhf-information-for-health-care-practitioners_2009.pdf) (in short dengue fever) is one of the most widespread mosquito-borne diseases in the most tropical and subtropical regions. It is an acute disease caused by dengue virus infection which is transmitted by female Aedes aegypti and Aedes albopictus mosquitoes. In 2015, Taiwan had recorded the most severe dengue fever outbreak with more than 43,000 dengue cases and 228 deaths. Since then, the annual reported dengue fever cases were maintained at the level of not more than 200 cases. However, in 2023, Taiwan recorded 26703 dengue fever cases.\n\n## 1.2 Objectives\n\nAs a curious geospatial analytics green horn, you are interested to discover:\n\n-   if the distribution of dengue fever outbreak at Tainan City, Taiwan are independent from space and space and time.\n\n-   If the outbreak is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.\n\n## 1.3 The Task\n\nThe specific tasks of this take-home exercise are as follows:\n\n-   Using appropriate function of **sf** and **tidyverse**, preparing the following geospatial data layer:\n\n    -   a study area layer in sf polygon features. It must be at village level and confined to the D01, D02, D04, D06, D07, D08, D32 and D39 counties of Tainan City, Taiwan.\n\n    -   a dengue fever layer within the study area in sf point features. The dengue fever cases should be confined to epidemiology week 31-50, 2023.\n\n    -   a derived dengue fever layer in [spacetime s3 class of sfdep](https://sfdep.josiahparry.com/articles/spacetime-s3). It should contain, among many other useful information, a data field showing number of dengue fever cases by village and by epidemiology week.\n\n-   Using the extracted data, perform global spatial autocorrelation analysis by using [sfdep methods](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa).\n\n-   Using the extracted data, perform local spatial autocorrelation analysis by using [sfdep methods](https://r4gdsa.netlify.app/chap10.html).\n\n-   Using the extracted data, perform emerging hotspot analysis by using [sfdep methods](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-ehsa).\n\n-   Describe the spatial patterns revealed by the analysis above.\n\n# 2.0 Packages\n\nThe packages used in this project are:\n\n-   **sf:** for importing, managing, and processing geospatial data\n\n-   **tidyverse**: a family of R packages for performing data science tasks such as importing, wrangling, and visualizing data\n\n-   **tmap:** creating thematic maps\n\n-   **sfdep:** for analyzing spatial dependencies\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap, sfdep, dplyr, zoo)\n```\n:::\n\n\n# 3.0 Data Acquisition\n\nFor the purpose of this take-home exercise, two data sets are provided, they are:\n\n+---------------------+----------+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+\n| Data                | Format   | Description                                                                                                               | Source                                                                                                              |\n+=====================+==========+===========================================================================================================================+=====================================================================================================================+\n| TAIWAN_VILLAGE_2020 | ESRI     | A Geospatial data of village boundary of Taiwan. The data is in Taiwan Geographic Coordinate System.                      | [Historical map data of the village boundary: TWD97 longitude and latitude](https://data.gov.tw/en/datasets/130549) |\n+---------------------+----------+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+\n| Dengue_Daily.csv    | CSV      | An Aspatial data of reported dengue cases in Taiwan since 1998. Below are selected fields that are useful for this study: | [Dengue Daily Confirmed Cases Since 1998](https://data.cdc.gov.tw/en/dataset/dengue-daily-determined-cases-1998)    |\n|                     |          |                                                                                                                           |                                                                                                                     |\n|                     |          | -   發病日: Onset date                                                                                                    |                                                                                                                     |\n|                     |          |                                                                                                                           |                                                                                                                     |\n|                     |          | -   最小統計區中心點X: x-coordinate                                                                                       |                                                                                                                     |\n|                     |          |                                                                                                                           |                                                                                                                     |\n|                     |          | -   最小統計區中心點Y: y-coordinate                                                                                       |                                                                                                                     |\n+---------------------+----------+---------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------+\n\n# 4.0 Data Wrangling\n\nCan reference In-Class_Ex05\n\n## 4.1 Importing Taiwan Boundary dataset\n\nLet's see what layers the dataset has.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile_path = \"../../data/geospatial/TAIWAN_VILLAGE_2020\"\nlayers <- st_layers(file_path)\nprint(layers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDriver: ESRI Shapefile \nAvailable layers:\n      layer_name geometry_type features fields crs_name\n1 TAINAN_VILLAGE       Polygon      649     10    TWD97\n```\n:::\n:::\n\n\nSince it only has one \"TAINAN_VILLAGE\" layer, lets pull it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntaiwan_sf <- st_read(dsn=\"../../data/geospatial/TAIWAN_VILLAGE_2020\", layer=\"TAINAN_VILLAGE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `TAINAN_VILLAGE' from data source \n  `C:\\russelltjh\\IS415-GAA\\data\\geospatial\\TAIWAN_VILLAGE_2020' \n  using driver `ESRI Shapefile'\nSimple feature collection with 649 features and 10 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.0269 ymin: 22.88751 xmax: 120.6563 ymax: 23.41374\nGeodetic CRS:  TWD97\n```\n:::\n:::\n\n\nTake note that this dataset is in TWD97 Geographic Coordinate System.\n\n### 4.1.1 Extracting Polygon Study Area\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(taiwan_sf,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 10 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.2695 ymin: 22.93251 xmax: 120.2905 ymax: 22.96072\nGeodetic CRS:  TWD97\n     VILLCODE COUNTYNAME TOWNNAME VILLNAME     VILLENG COUNTYID COUNTYCODE\n1 67000280002     臺南市   歸仁區   六甲里 Liujia Vil.        D      67000\n  TOWNID TOWNCODE NOTE                       geometry\n1    D33 67000280 <NA> POLYGON ((120.2725 22.95868...\n```\n:::\n:::\n\n\nWe are interested in the \"TOWNID\" column. Specifically the D01, D02, D04, D06, D07, D08, D32 and D39 counties of Tainan City, Taiwan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming taiwan_sf is your imported sf object\nstudy_area_sf <- taiwan_sf %>%\n  filter(TOWNID %in% c(\"D01\", \"D02\", \"D04\", \"D06\", \"D07\", \"D08\", \"D32\", \"D39\"))\n\n# Check the result\nprint(unique(study_area_sf$TOWNID))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"D06\" \"D32\" \"D08\" \"D02\" \"D39\" \"D01\" \"D04\" \"D07\"\n```\n:::\n:::\n\n\n### 4.1.2 Drop Unnecessary Columns\n\nLet's drop the \"NOTE\" column from the dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only the necessary columns\nstudy_area_sf <- study_area_sf %>%\n  select(VILLCODE, COUNTYNAME, TOWNNAME, VILLNAME, VILLENG, COUNTYID, COUNTYCODE, TOWNID, TOWNCODE, geometry)\n\n# Check the result\nprint(study_area_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 258 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 120.0627 ymin: 22.89401 xmax: 120.2925 ymax: 23.09144\nGeodetic CRS:  TWD97\nFirst 10 features:\n      VILLCODE COUNTYNAME TOWNNAME VILLNAME       VILLENG COUNTYID COUNTYCODE\n1  67000350032     臺南市   安南區   青草里  Qingcao Vil.        D      67000\n2  67000270011     臺南市   仁德區   保安里   Bao'an Vil.        D      67000\n3  67000370005     臺南市   中西區   赤嵌里  Chihkan Vil.        D      67000\n4  67000330004     臺南市     南區   大成里  Dacheng Vil.        D      67000\n5  67000350028     臺南市   安南區   城北里 Chengbei Vil.        D      67000\n6  67000350030     臺南市   安南區   城南里 Chengnan Vil.        D      67000\n7  67000370009     臺南市   中西區   法華里    Fahua Vil.        D      67000\n8  67000350017     臺南市   安南區   海南里   Hainan Vil.        D      67000\n9  67000350049     臺南市   安南區   國安里   Guo'an Vil.        D      67000\n10 67000350018     臺南市   安南區   溪心里    Xixin Vil.        D      67000\n   TOWNID TOWNCODE                       geometry\n1     D06 67000350 POLYGON ((120.1176 23.08387...\n2     D32 67000270 POLYGON ((120.2304 22.93544...\n3     D08 67000370 POLYGON ((120.2012 22.99966...\n4     D02 67000330 POLYGON ((120.1985 22.98147...\n5     D06 67000350 POLYGON ((120.1292 23.06512...\n6     D06 67000350 POLYGON ((120.1246 23.06904...\n7     D08 67000370 POLYGON ((120.2094 22.98452...\n8     D06 67000350 POLYGON ((120.175 23.02218,...\n9     D06 67000350 POLYGON ((120.1866 23.02766...\n10    D06 67000350 POLYGON ((120.1834 23.06086...\n```\n:::\n:::\n\n\n## 4.2 Importing Dengue Daily dataset\n\nThis dataset contains the dengue cases in 2020 and is in TWD97 Geographic Coordinate System.\n\nThe data is in a geographic coordinate system with longitude and latitude, even though it is in decimal. It is not Projected Coordinate System.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue2023 <- read_csv(\"../../data/aspatial/DengueDaily/Dengue_Daily.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(dengue2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     發病日            個案研判日            通報日          \n Min.   :1998-01-02   Length:106861      Min.   :1998-01-07  \n 1st Qu.:2014-10-28   Class :character   1st Qu.:2014-10-31  \n Median :2015-09-29   Mode  :character   Median :2015-10-01  \n Mean   :2016-03-31                      Mean   :2016-04-03  \n 3rd Qu.:2023-06-19                      3rd Qu.:2023-06-23  \n Max.   :2024-01-29                      Max.   :2024-01-29  \n     性別              年齡層            居住縣市           居住鄉鎮        \n Length:106861      Length:106861      Length:106861      Length:106861     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n   居住村里          最小統計區        最小統計區中心點X  最小統計區中心點Y \n Length:106861      Length:106861      Length:106861      Length:106861     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n  一級統計區         二級統計區          感染縣市           感染鄉鎮        \n Length:106861      Length:106861      Length:106861      Length:106861     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n   感染村里         是否境外移入         感染國家           確定病例數\n Length:106861      Length:106861      Length:106861      Min.   :1   \n Class :character   Class :character   Class :character   1st Qu.:1   \n Mode  :character   Mode  :character   Mode  :character   Median :1   \n                                                          Mean   :1   \n                                                          3rd Qu.:1   \n                                                          Max.   :2   \n 居住村里代碼       感染村里代碼          血清型          內政部居住縣市代碼\n Length:106861      Length:106861      Length:106861      Length:106861     \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n 內政部居住鄉鎮代碼 內政部感染縣市代碼 內政部感染鄉鎮代碼\n Length:106861      Length:106861      Length:106861     \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n                                                         \n                                                         \n                                                         \n```\n:::\n:::\n\n\n### 4.2.1 Extract Study Area\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First, convert '發病日' to Date format\ndengue2023 <- dengue2023 %>%\n  mutate(發病日期 = ymd(發病日))\n\n# Then, add a column for the epidemiological week and year\ndengue2023 <- dengue2023 %>%\n  mutate(\n    EPID_WEEK = isoweek(發病日期),\n    EPID_YEAR = year(發病日期)\n  )\n\n# Now, filter the data for epidemiological weeks 31-50 in 2023\ndengue_week31_50_2023 <- dengue2023 %>%\n  filter(EPID_YEAR == 2023 & EPID_WEEK >= 31 & EPID_WEEK <= 50)\n\n# Check the result\nprint(dengue_week31_50_2023)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25,480 × 29\n   發病日     個案研判日 通報日     性別  年齡層 居住縣市 居住鄉鎮 居住村里\n   <date>     <chr>      <date>     <chr> <chr>  <chr>    <chr>    <chr>   \n 1 2023-07-31 2023/07/31 2023-07-31 女    30-34  台南市   永康區   埔園里  \n 2 2023-07-31 2023/07/31 2023-07-31 男    55-59  台南市   東區     大智里  \n 3 2023-07-31 2023/07/31 2023-07-31 男    5-9    台南市   永康區   五王里  \n 4 2023-07-31 2023/07/31 2023-07-31 男    70+    台南市   仁德區   成功里  \n 5 2023-07-31 2023/07/31 2023-07-31 男    55-59  台南市   永康區   中興里  \n 6 2023-07-31 2023/07/31 2023-07-31 男    30-34  雲林縣   古坑鄉   高林村  \n 7 2023-07-31 2023/07/31 2023-07-31 女    40-44  台南市   永康區   復華里  \n 8 2023-07-31 2023/08/01 2023-08-01 女    30-34  台南市   仁德區   仁德里  \n 9 2023-07-31 2023/08/01 2023-08-01 男    70+    雲林縣   古坑鄉   荷苞村  \n10 2023-07-31 2023/08/01 2023-08-01 男    15-19  台南市   東區     崇善里  \n# ℹ 25,470 more rows\n# ℹ 21 more variables: 最小統計區 <chr>, 最小統計區中心點X <chr>,\n#   最小統計區中心點Y <chr>, 一級統計區 <chr>, 二級統計區 <chr>,\n#   感染縣市 <chr>, 感染鄉鎮 <chr>, 感染村里 <chr>, 是否境外移入 <chr>,\n#   感染國家 <chr>, 確定病例數 <dbl>, 居住村里代碼 <chr>, 感染村里代碼 <chr>,\n#   血清型 <chr>, 內政部居住縣市代碼 <chr>, 內政部居住鄉鎮代碼 <chr>,\n#   內政部感染縣市代碼 <chr>, 內政部感染鄉鎮代碼 <chr>, 發病日期 <date>, …\n```\n:::\n:::\n\n\n### 4.2.2 Drop Unnecessary Columns\n\nIn the Data Acquisition section, we mentioned that we only need these columns for the analysis:\n\n-   發病日: Onset date\n\n    -   Since in the above processing, we created a new field called (發病日期) with the modified date object, we will use that instead.\n\n-   最小統計區中心點X: x-coordinate\n\n-   最小統計區中心點Y: y-coordinate\n\n-   EPID_WEEK: Epidemiology Week\n\nLet's keep only these 4 columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select only the necessary columns\ndengue_cases <- dengue_week31_50_2023 %>%\n  select(發病日期, 最小統計區中心點X, 最小統計區中心點Y, EPID_WEEK)\n\n# Check the result\nprint(dengue_cases)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25,480 × 4\n   發病日期   最小統計區中心點X 最小統計區中心點Y EPID_WEEK\n   <date>     <chr>             <chr>                 <dbl>\n 1 2023-07-31 120.253752333     23.031699814             31\n 2 2023-07-31 120.232374917     22.962366283             31\n 3 2023-07-31 120.235733496     23.013083716             31\n 4 2023-07-31 120.225744179     22.957479956             31\n 5 2023-07-31 120.236501733     23.004533744             31\n 6 2023-07-31 120.569102533     23.671263060             31\n 7 2023-07-31 120.248094155     23.014554416             31\n 8 2023-07-31 120.251073582     22.971075521             31\n 9 2023-07-31 120.584381057     23.668717366             31\n10 2023-07-31 120.231829094     22.972059640             31\n# ℹ 25,470 more rows\n```\n:::\n:::\n\n\n### 4.2.3 Convert Coordinates to numeric values\n\nI noticed that the coordinates are in 'chr' character strings. We need them to be in numeric.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_cases <- dengue_cases %>%\n  mutate(\n    最小統計區中心點X = as.numeric(最小統計區中心點X),\n    最小統計區中心點Y = as.numeric(最小統計區中心點Y)\n  ) %>%\n  na.omit()\n```\n:::\n\n\n## 4.3 Combining and Aggregating the data\n\n### 4.3.1 Spatial Join\n\nPerform a spatial join between the **`dengue_cases`** points and the **`study_area_sf`** polygons to determine which dengue cases occur in which village.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Spatial Join\n# Convert dengue_cases to an sf object by using the coordinates\ndengue_cases_sf <- st_as_sf(dengue_cases, coords = c(\"最小統計區中心點X\", \"最小統計區中心點Y\"), crs = st_crs(study_area_sf))\n\n# Perform the spatial join\nstudy_area_cases_sf <- st_join(study_area_sf, dengue_cases_sf) %>%\n  na.omit()\n```\n:::\n\n\n### 4.3.2 Aggregation by VILLENG\n\nAggregate the cases by the 'VILLENG' (village name)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 3: Aggregation\n# Aggregate by village name (VILLENG) and epidemiological week\nstudy_area_aggregated <- study_area_cases_sf %>%\n  group_by(VILLENG) %>%\n  summarise(CASE_COUNT = n())\n```\n:::\n\n\n## 4.4 Visualizing Data\n\nDraw a choropleth map\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(study_area_aggregated) +\n  tm_fill(\"CASE_COUNT\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\")\n\nquantile <- tm_shape(study_area_aggregated) +\n  tm_fill(\"CASE_COUNT\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\")\n\ntmap_arrange(equal, \n             quantile, \n             asp=1, \n             ncol=2)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## 4.5 Spacetime Object\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 3: Aggregation\n# Aggregate by village name (VILLENG) and epidemiological week\nstudy_area_time_aggregated <- study_area_cases_sf %>%\n  group_by(VILLENG, EPID_WEEK) %>%\n  summarise(CASE_COUNT = n())\n```\n:::\n\n\n### 4.5.1 Expanding the data\n\nOur aggregated dataset only stores the data of cases that occur. However, there will be location and times where no cases occur. We need to expand our data to include those rows with CASE_COUNT values of 0. This is to make the spacetime object creation smoother.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a full grid of location and time period combinations\nfull_grid <- expand.grid(\n  VILLENG = unique(study_area_sf$VILLENG),\n  EPID_WEEK = unique(study_area_time_aggregated$EPID_WEEK)\n)\n\n# Join the grid with spatial data to ensure geometry is present for all villages\nfull_grid_with_geom <- left_join(full_grid, study_area_sf %>% select(VILLENG, geometry), by = \"VILLENG\")\n\n# Join the spatially enriched grid with case count data\ncomplete_data <- left_join(full_grid_with_geom, study_area_aggregated, by = c(\"VILLENG\", \"EPID_WEEK\"))\n\n# Replace NA values in CASE_COUNT with zero \ncomplete_data$CASE_COUNT[is.na(complete_data$CASE_COUNT)] <- 0\n\n# Convert back to an sf object \ncomplete_data <- complete_data %>%\n  select(-geometry.x) %>%\n  rename(geometry = geometry.y)\n\ncomplete_data_sf <- st_as_sf(complete_data, sf_column_name = \"geometry\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming 'complete_data_sf' is your prepared sf object before attempting to create the spacetime cube\n\n# Aggregate to ensure one observation per location-time combination\n# Replace 'CASE_COUNT' with your actual case count column, if named differently\naggregated_data <- complete_data_sf %>%\n  group_by(VILLENG, EPID_WEEK) %>%\n  summarize(CASE_COUNT = sum(CASE_COUNT), .groups = 'drop')\n\n# Ensure the aggregated data is still an sf object\naggregated_data_sf <- st_as_sf(aggregated_data, sf_column_name = \"geometry\", crs = st_crs(complete_data_sf))\n\n# Try creating the spacetime object again\ndengue_st <- spacetime(\n  aggregated_data_sf, \n  study_area_sf, \n  \"VILLENG\", \n  \"EPID_WEEK\"\n)\n\n# Attempt to complete the spacetime cube\ndengue_st_cube <- complete_spacetime_cube(dengue_st)\n```\n:::\n\n\n### 4.5.2 Spacetime Cube Object Creation\n\nCreate an spacetime cube object using **`sfdep`** package, which will allow for the analysis of spatial and spatio-temporal patterns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndengue_st <- spacetime(\n  complete_data_sf, \n  study_area_sf, \n  \"VILLENG\", \n  \"EPID_WEEK\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis_spacetime_cube(dengue_st)\n```\n:::\n\n\nSeems like the in certain locations, case_count might have missing values since there could possible be no cases in that location and time period. Let's fill the missing values with NA using the complete_spacetime_cube() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming dengue_st is your current spacetime object\ndengue_st_cube <- complete_spacetime_cube(dengue_st)\n\n# Check if the object is now a valid spacetime cube\nis_spacetime_cube(dengue_st_cube)\n```\n:::\n\n\n# 5.0 Global Spatial Autocorrelation\n\nGlobal Spatial Autocorrelation measures the overall degree of spatial dependence within a geographic area. The most common statistic for measuring global spatial autocorrelation is Moran's I. This statistic compares the value of spatial data at one location with values at neighboring locations over the entire study area to determine if there is a significant pattern. If Moran's I is positive and significant, it suggests a clustered pattern; if it is negative and significant, it suggests a dispersed pattern; if it is close to zero, it indicates a random spatial pattern.\n\nGlobal Autocorrelation Analysis:\n\n-   Calculate Moran's I for the entire study area\n\n-   Assess the significance of the statistic to determine if there is a pattern\n\n-   Interpret the result to understand the overall tendency of data clustering or dispersion\n\n## 5.1 Computing Contiguity Spatial Weights\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nWe will derive the contiguity weights using the **Queen's method**. (Similar to the way a Queen moves in chess, we will take into account neighbors in all principal directions - cardinal and intercardinal)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- study_area_aggregated %>%\n  mutate(nb = st_contiguity(geometry),\n         wt = st_weights(nb,\n                         style = \"W\"),\n         .before = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 248 features and 4 fields\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 120.0627 ymin: 22.89401 xmax: 120.2925 ymax: 23.09144\nGeodetic CRS:  TWD97\n# A tibble: 248 × 5\n   nb        wt        VILLENG     CASE_COUNT                           geometry\n * <nb>      <list>    <chr>            <int>                      <POLYGON [°]>\n 1 <int [5]> <dbl [5]> Andong Vil.         67 ((120.2164 23.0404, 120.2154 23.0…\n 2 <int [5]> <dbl [5]> Anfu Vil.          311 ((120.1932 23.0294, 120.1929 23.0…\n 3 <int [7]> <dbl [7]> Anhe Vil.           73 ((120.2258 23.04424, 120.2219 23.…\n 4 <int [3]> <dbl [3]> Ankang Vil.         96 ((120.2269 23.01413, 120.2274 23.…\n 5 <int [4]> <dbl [4]> Anqing Vil.        111 ((120.2113 23.04414, 120.2111 23.…\n 6 <int [3]> <dbl [3]> Anshun Vil.         34 ((120.2136 23.05601, 120.2136 23.…\n 7 <int [8]> <dbl [8]> Anxi Vil.          110 ((120.2123 23.03689, 120.212 23.0…\n 8 <int [5]> <dbl [5]> Bao'an Vil.         19 ((120.2304 22.93544, 120.2301 22.…\n 9 <int [6]> <dbl [6]> Beihua Vil.         82 ((120.2034 23.00257, 120.2032 23.…\n10 <int [4]> <dbl [4]> Beimen Vil.        249 ((120.2176 23.02032, 120.2173 23.…\n# ℹ 238 more rows\n```\n:::\n:::\n\n\n## 5.2 Performing Global Moran's I Test\n\nLet's run the Global Moran's I test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$CASE_COUNT,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 11.884, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.436433657      -0.004048583       0.001373754 \n```\n:::\n:::\n\n\n## 5.3 Performing Global Moran's I Permutation Test\n\nWe will apply Monte Carlo simulation to perform the statistical test 100 times.\n\nFirst, we set a seed to maintain the reproduceability of the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8888)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_perm(wm_q$CASE_COUNT,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim = 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 101 \n\nstatistic = 0.43643, observed rank = 101, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n:::\n\n\nThe statistical report shows that the p-value is smaller than alpha value 0.05.\n\nTherefore, we have enough evidence to **reject** the null hypothesis that the **spatial distribution of cases resembles random distribution**.\n\nSince Moran's I statistics is greater than 0, we can infer that the **spatial distribution show signs of clustering**.\n\n# 6.0 Local Spatial Autocorrelation\n\nLocal Spatial Autocorrelation breaks down the global statistic into contributions from each individual location, allowing for the assessment of where and how much each feature contributes to the overall autocorrelation statistic. Local indicators of spatial association (LISA), such as Local Moran's I, allow for the identification of clusters or outliers where a feature has a value significantly different from its neighbors. This local approach helps to pinpoint specific areas of interest within the global context.\n\nLocal Autocorrelation Analysis:\n\n-   Calculate Local Moran's I for each feature in the dataset\n\n-   Create a significance map that highlights areas of significant local clustering or outliers\n\n-   Use this detailed view to identify hot spots (high values surrounded by high values), cold spots (low values surrounded by low values), and spatial outliers (high values surrounded by low values or vice versa)\n\n## 6.1 Computing Local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>% \n  mutate(local_moran = local_moran(\n    CASE_COUNT, nb, wt, nsim = 99),\n         .before = 1) %>%\n  unnest(local_moran)\n```\n:::\n\n\nThe output of local_moran() is a sf data.frame containing some of the following columns:\n\n+----------------+-------------------------------------------------------------------------+\n| Column         | Description                                                             |\n+================+=========================================================================+\n| ii             | Local Moran statistic                                                   |\n+----------------+-------------------------------------------------------------------------+\n| eii            | Expected Local Moran statistic; or the permutation sample mean          |\n+----------------+-------------------------------------------------------------------------+\n| var_ii         | Variance of Local Moran statistic; or the permutation sample deviations |\n+----------------+-------------------------------------------------------------------------+\n| z_ii           | Standard deviate of Local Moran statistic                               |\n+----------------+-------------------------------------------------------------------------+\n| p_ii           | p-value of Local Moran statistic using pnorm()                          |\n+----------------+-------------------------------------------------------------------------+\n\n## 6.2 Visualizing Local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_fill(\"ii\") + \n  tm_borders(alpha = 0.5) +\n  tm_view(set.zoom.limits = c(6,8)) +\n  tm_layout(main.title = \"local Moran's I of Case Count\",\n            main.title.size = 0.8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n## 6.3 Visualizing p-value of local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_fill(\"p_ii_sim\") + \n  tm_borders(alpha = 0.5) +\n   tm_layout(main.title = \"p-value of local Moran's I\",\n            main.title.size = 0.8)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n## 6.4 Visualizing LISA map\n\nThe LISA map will categorize each region to show the outliers and clusters.\n\nTypes of clusters and outliers:\n\n| Clusters  | Outliers |\n|-----------|----------|\n| High-High | High-Low |\n| Low-Low   | Low-High |\n\nIn the lisa sf data.frame, there are 3 fields: mean, median and pysal. In general, classification in mean will be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa  %>%\n  filter(p_ii < 0.05)\ntmap_mode(\"plot\")\ntm_shape(lisa) +\n  tm_polygons() +\n  tm_borders(alpha = 0.5) +\ntm_shape(lisa_sig) +\n  tm_fill(\"mean\") + \n  tm_borders(alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex02_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n# 7.0 Emerging Hot Spot and Cold Spot Area Analysis (HCSA)\n\nEmerging Hot Spot Analysis (EHSA) is a spatio-temporal analysis method for revealing and describing how hot spot and cold spot areas evolve over time.\n\nEmerging Hot Spot Analysis:\n\n-   Build a spacetime cube\n\n-   Calculate Getis-Ord local Gi\\* statistic for each bin by using an FDR correction\n\n-   Evaluating these hot and cold spot trends by using Mann-Kendall trend test\n\n-   Categorizing each study area location by referring to the resultant trend z-score and p-value for each location with data, and with the hot spot z-score and p-value for each bin.\n\n## 7.1 Computing Local Gi\\* statistics\n\n\n::: {.cell}\n\n:::\n\n\n# Global Measures of Spatial Association (Ex05)\n\n[is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa](https://is415-gaa-tskam.netlify.app/in-class_ex/in-class_ex05/in-class_ex05-glsa)\n\nDeriving contiguity weights: Queen's method\n\nThen draw a bunch of choropleth map\n\nwhen using sfdep, the wm_q will be saved as dataframe. This means we can just look at the neighbors by looking directly at the dataset (like the in-class exercise), instead of only being able to look at it after printing (like the hands-on exercise)\n\nMoran I test statistics: use p-value to compare with critical value to reject or accept null hypothesis. (usually using 95% -\\> alpha value = 0.05 or 90% -\\> alpha value = 0.1)\n\n-   Reject Null Hypothesis if p-value \\< critical value -\\> inferred .... represents clustering\n\nIs there a spacial bias-ness? Test its distribution (like Complete Spatial Randomness, or does it have some clustering). The null hypothesis is that it resembles CSR.\n\nThis stuff is called Frequentist test because we only take one result. But in the modern data science world, we don't use this because it's not enough, instead we use monte-carlo simulation to test it multiple times. For this assignment, we can just use monte carlo.\n\nglobal_moran_perm(wm_q\\$GDPPC, wm_q\\$nb, wm_q\\$wt, nsim = 99)\n\nCorrect method to use is always permutation method.\n\nMOVING ON\n\nlocal moran is a decomposition of moran, so we can detect specific cluster outliers\n\n-   Outlier =\\> different from neighbors (high-low, low-high)\n\n-   Clusters =\\> similar to neighbors (high-high, low-low)\n\nWe can plot the p-value for each region\n\nlisa_sig \\<- lisa %\\>% filter(p_ii \\< 0.05) tmap_mode(\"plot\") .......................\n\nMOVING ON\n\nGi\\* statistics, it needs to be in distance based metrics\n\nGi\\* statistics defines everything as a cluster and tells us if its a hotspot or coldspot cluster\n\ncan use fixed distance, adaptive distance or inverse distance (like in-class ex)\n\nThe graph from GI will have positive and negative\n\n-   positive = hotspot\n\n-   negative = coldspot\n\nMOVING ON\n\nwe can combine both, the statistically significant areas from local moran and the hotspot/coldspot from Gi\\* statistics\n\nFOR THIS TAKE HOME ASSIGNMENT, we need to decide which one to use, and see if we need both or just one\n\nMOVING ON\n\nSPATIAL TIME CUBE\n\neach cube represents one geographical area.\n\n# Local Measures of Spatial Association\n\n# Emerging Hotspot Analysis\n",
    "supporting": [
      "Take-home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}